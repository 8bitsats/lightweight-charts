<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,minimum-scale=1.0">
    <title>Lightweight Charts Example - Price Markers</title>
    <script type="module" src="../dist/lightweight-charts.standalone.development.mjs"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            margin: 0;
            padding: 20px;
        }
        .container {
            display: flex;
            flex-direction: column;
            max-width: 1000px;
            margin: 0 auto;
        }
        .chart-container {
            height: 400px;
            position: relative;
        }
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 20px;
            padding: 15px;
            background-color: #f5f5f5;
            border-radius: 5px;
        }
        .control-group {
            display: flex;
            flex-direction: column;
            min-width: 150px;
        }
        label {
            font-size: 12px;
            margin-bottom: 5px;
            font-weight: bold;
        }
        input, select, button {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        button {
            background-color: #2962FF;
            color: white;
            border: none;
            cursor: pointer;
            padding: 10px 15px;
            font-weight: bold;
        }
        button:hover {
            background-color: #0039CB;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Price Markers Example</h1>
        <p>This example demonstrates how to place markers at specific price levels on the chart.</p>
        
        <div class="chart-container" id="chart"></div>
        
        <div class="controls">
            <div class="control-group">
                <label for="time">Time:</label>
                <select id="time"></select>
            </div>
            <div class="control-group">
                <label for="price">Price:</label>
                <input type="number" id="price" step="0.01">
            </div>
            <div class="control-group">
                <label for="shape">Shape:</label>
                <select id="shape">
                    <option value="circle">Circle</option>
                    <option value="square">Square</option>
                    <option value="arrowUp">Arrow Up</option>
                    <option value="arrowDown">Arrow Down</option>
                </select>
            </div>
            <div class="control-group">
                <label for="color">Color:</label>
                <input type="color" id="color" value="#2962FF">
            </div>
            <div class="control-group">
                <label for="position">Position:</label>
                <select id="position">
                    <option value="inBar">In Bar</option>
                    <option value="aboveBar">Above Bar</option>
                    <option value="belowBar">Below Bar</option>
                    <option value="atPriceTop">At Price (Top)</option>
                    <option value="atPriceBottom">At Price (Bottom)</option>
                    <option value="atPriceMiddle">At Price (Middle)</option>
                </select>
            </div>
            <div class="control-group">
                <label for="text">Text:</label>
                <input type="text" id="text" placeholder="Optional">
            </div>
            <div class="control-group">
                <label>&nbsp;</label>
                <button id="add-marker">Add Marker</button>
            </div>
            <div class="control-group">
                <label>&nbsp;</label>
                <button id="clear-markers">Clear All Markers</button>
            </div>
            <div class="control-group">
                <label>&nbsp;</label>
                <button id="test-positions">Test Marker Positions</button>
            </div>
            <div class="control-group">
                <label>&nbsp;</label>
                <button id="add-example-markers">Add Example Markers</button>
            </div>
            <div class="control-group">
                <label>&nbsp;</label>
                <button id="debug-marker">Debug Marker Position</button>
            </div>
            <div class="control-group">
                <label>&nbsp;</label>
                <button id="monitor-coordinates">Monitor Price Coordinates</button>
            </div>
        </div>
    </div>

    <script type="module">
        // Create a debug info element for logging
        const debugInfo = document.createElement('div');
        debugInfo.style.margin = '20px auto';
        debugInfo.style.maxWidth = '1000px';
        debugInfo.style.padding = '10px';
        debugInfo.style.backgroundColor = '#f5f5f5';
        debugInfo.style.border = '1px solid #ddd';
        debugInfo.style.borderRadius = '5px';
        debugInfo.style.fontFamily = 'monospace';
        document.querySelector('.container').appendChild(debugInfo);
        
        function log(message) {
            console.log(message);
            debugInfo.innerHTML += message + '<br>';
        }
        
        try {
            log("Loading module...");
            
            // Import the module using a promise-based approach for better error handling
            import('./dist/lightweight-charts.standalone.development.mjs')
            .then(module => {
                log("Module loaded successfully.");
                
                // Log available exports for debugging
                log("Available exports: " + Object.keys(module).join(", "));
                
                // Create a standalone function for series markers for consistency
                const createSeriesMarkersFunction = module.createSeriesMarkers;
                log("Using native createSeriesMarkers API for all markers");
                
                // Note: The SeriesMarker interface already includes a 'price' property
                // which can be used for exact Y-axis positioning. No need for a separate plugin.
                log("Note: The SeriesMarker interface includes a 'price' property for exact Y-axis positioning");
                
                // Generate sample data
                function generateData() {
                    const data = [];
                    const startTime = new Date(Date.UTC(2018, 0, 1, 0, 0, 0, 0));
                    const endTime = new Date(Date.UTC(2018, 1, 1, 0, 0, 0, 0));
                    let time = startTime;
                    
                    let baseValue = 10 + Math.random() * 50;
                    let volatility = 0.1;
                    
                    while (time <= endTime) {
                        const openValue = baseValue * (1 + (Math.random() - 0.5) * volatility);
                        const highValue = openValue * (1 + Math.random() * volatility);
                        const lowValue = openValue * (1 - Math.random() * volatility);
                        const closeValue = (openValue + highValue + lowValue) / 3;
                        
                        data.push({
                            time: Math.floor(time.getTime() / 1000),
                            open: openValue,
                            high: highValue,
                            low: lowValue,
                            close: closeValue,
                        });
                        
                        baseValue = closeValue;
                        time.setDate(time.getDate() + 1);
                    }
                    
                    return data;
                }
                
                try {
                    // Initialize chart
                    log("Creating chart...");
                    const chartElement = document.getElementById('chart');
                    const chart = module.createChart(chartElement, {
                        width: chartElement.clientWidth,
                        height: chartElement.clientHeight,
                        layout: {
                            background: { color: '#ffffff' },
                            textColor: '#333',
                        },
                        grid: {
                            vertLines: { color: '#f0f0f0' },
                            horzLines: { color: '#f0f0f0' },
                        },
                        crosshair: {
                            mode: module.CrosshairMode.Normal,
                        },
                        rightPriceScale: {
                            borderColor: '#d1d4dc',
                        },
                        timeScale: {
                            borderColor: '#d1d4dc',
                        },
                    });
                    
                    log("Chart created successfully.");
                    
                    // Create candlestick series
                    log("Adding candlestick series...");
                    const candlestickSeries = chart.addSeries(module.CandlestickSeries, {
                        upColor: '#26a69a',
                        downColor: '#ef5350',
                        borderVisible: false,
                        wickUpColor: '#26a69a',
                        wickDownColor: '#ef5350',
                    });
                    
                    log("Candlestick series added.");
                    
                    // Set data
                    const data = generateData();
                    candlestickSeries.setData(data);
                    
                    // Populate time dropdown
                    const timeSelect = document.getElementById('time');
                    data.forEach((candle, index) => {
                        const option = document.createElement('option');
                        const date = new Date(candle.time * 1000);
                        option.value = candle.time;
                        option.text = date.toLocaleDateString();
                        timeSelect.appendChild(option);
                    });
                    
                    // Set default price value
                    document.getElementById('price').value = data[Math.floor(data.length / 2)].close.toFixed(2);
                    
                    // Store markers
                    let markers = [];
                    
                    // Function to add a price marker
                    function addPriceMarker() {
                        const time = parseInt(document.getElementById('time').value);
                        const price = parseFloat(document.getElementById('price').value);
                        const shape = document.getElementById('shape').value;
                        const color = document.getElementById('color').value;
                        const position = document.getElementById('position').value;
                        const text = document.getElementById('text').value || `Price: ${price.toFixed(2)}`;
                        
                        // Debug: Check price-to-coordinate conversion
                        const priceCoordinate = candlestickSeries.priceToCoordinate(price);
                        log(`Debug - Price ${price} converts to Y coordinate: ${priceCoordinate}`);
                        
                        // Create a marker with the price property for exact Y-axis positioning
                        const marker = {
                            time: time,
                            position: position,
                            shape: shape,
                            color: color,
                            text: text,
                            price: price // Always include the price property for all marker types
                        };
                        
                        // Add the marker to our array
                        markers.push(marker);
                        
                        // Add the marker to the chart
                        log("Adding marker at time: " + time + ", price: " + price + ", position: " + position);
                        try {
                            // Add the marker directly - no need for special handling based on position
                            createSeriesMarkersFunction(candlestickSeries, [marker]);
                            log("Marker added at price: " + price);
                            
                            // Debug: Verify the round-trip conversion
                            const backToCoordinate = candlestickSeries.priceToCoordinate(price);
                            log(`Debug - Round trip: Price ${price.toFixed(2)} converts back to Y coordinate: ${backToCoordinate}`);
                        } catch (err) {
                            log("Error adding marker: " + err.message);
                            console.error("Marker error:", err);
                        }
                        
                        // Add a price line at the specified price
                        addPriceLine(price, color, text);
                    }
                    
                    // Function to add a price line
                    function addPriceLine(price, color, title) {
                        try {
                            candlestickSeries.createPriceLine({
                                price: price,
                                color: color,
                                lineWidth: 1,
                                lineStyle: 2, // Dashed line
                                axisLabelVisible: true,
                                title: title,
                            });
                            log("Price line added at: " + price);
                        } catch (err) {
                            log("Error adding price line: " + err.message);
                            console.error("Price line error:", err);
                        }
                    }
                    
                    // Add marker button click handler
                    document.getElementById('add-marker').addEventListener('click', addPriceMarker);
                    
                    // Clear markers button click handler
                    document.getElementById('clear-markers').addEventListener('click', () => {
                        markers = [];
                        // Clear markers by setting an empty array
                        try {
                            // Clear all markers
                            log("Clearing all markers...");
                            createSeriesMarkersFunction(candlestickSeries, []);
                            log("All markers cleared");
                        } catch (err) {
                            log("Error clearing markers: " + err.message);
                            console.error("Clear markers error:", err);
                        }
                        
                        // Remove all price lines by applying autoScale
                        candlestickSeries.priceScale().applyOptions({
                            autoScale: true,
                        });
                        
                        // Refresh the chart
                        chart.applyOptions({
                            width: chartElement.clientWidth,
                        });
                    });
                    
                    // Handle window resize
                    window.addEventListener('resize', () => {
                        chart.applyOptions({
                            width: chartElement.clientWidth,
                        });
                    });
                    
                    // Add click handler to chart
                    chart.subscribeClick((param) => {
                        if (param.point) {
                            const price = candlestickSeries.coordinateToPrice(param.point.y);
                            const time = candlestickSeries.coordinateToTime(param.point.x);
                            
                            if (price !== null && time !== null) {
                                log(`Clicked at Y coordinate: ${param.point.y}, converts to price: ${price.toFixed(2)}`);
                                log(`Clicked at time: ${new Date(time * 1000).toLocaleDateString()}`);
                                
                                // Debug: Verify the round-trip conversion
                                const backToCoordinate = candlestickSeries.priceToCoordinate(price);
                                log(`Debug - Round trip: Price ${price.toFixed(2)} converts back to Y coordinate: ${backToCoordinate}`);
                                
                                // Ask user if they want to add a marker
                                if (confirm(`Add a marker at price ${price.toFixed(2)}?`)) {
                                    // Set the values in the form
                                    document.getElementById('price').value = price.toFixed(2);
                                    document.getElementById('time').value = time;
                                    
                                    // Add the marker
                                    addPriceMarker();
                                }
                            }
                        }
                    });
                    
                    // Fit content to view
                    chart.timeScale().fitContent();
                    log("Chart setup complete. Try adding markers!");
                    
                    // Add a button to run the test
                    document.getElementById('test-positions').addEventListener('click', testMarkerPositions);
                    
                    // Add a function to demonstrate different price-based markers
                    function addExamplePriceMarkers() {
                        log("Adding example price-based markers...");
                        
                        // Clear existing markers
                        createSeriesMarkersFunction(candlestickSeries, []);
                        markers = [];
                        
                        // Get a time in the middle of the dataset
                        const midTime = data[Math.floor(data.length / 2)].time;
                        
                        // Define a set of test prices
                        const testPrices = [25, 30, 35, 40];
                        
                        // Create an array to hold all markers
                        const allMarkers = [];
                        
                        // Create markers at different price levels with different positions
                        testPrices.forEach((price, index) => {
                            // Define positions to test
                            const positions = [
                                'inBar', 
                                'aboveBar', 
                                'belowBar', 
                                'atPriceTop', 
                                'atPriceBottom', 
                                'atPriceMiddle'
                            ];
                            
                            // Create a marker for each position at this price
                            positions.forEach((position, posIndex) => {
                                // Calculate time offset to spread markers horizontally
                                const timeOffset = (posIndex - 2) * 86400; // One day in seconds
                                
                                const marker = {
                                    time: midTime + timeOffset,
                                    price: price,
                                    position: position,
                                    shape: 'circle',
                                    color: getColorForPosition(position),
                                    text: `${position} @ ${price}`,
                                    size: 1
                                };
                                
                                allMarkers.push(marker);
                                
                                // Add a price line for each price level (only once per price)
                                if (posIndex === 0) {
                                    addPriceLine(price, getColorForPosition('atPriceMiddle'), `Price: ${price}`);
                                }
                            });
                        });
                        
                        // Add all markers at once
                        try {
                            createSeriesMarkersFunction(candlestickSeries, allMarkers);
                            log(`Added ${allMarkers.length} price-based markers`);
                            
                            // Store markers
                            markers = allMarkers;
                        } catch (err) {
                            log("Error adding markers: " + err.message);
                            console.error("Marker error:", err);
                        }
                    }
                    
                    // Helper function to get a color for each position type
                    function getColorForPosition(position) {
                        const colors = {
                            'inBar': '#FF5722',
                            'aboveBar': '#4CAF50',
                            'belowBar': '#2196F3',
                            'atPriceTop': '#9C27B0',
                            'atPriceBottom': '#FFC107',
                            'atPriceMiddle': '#E91E63'
                        };
                        return colors[position] || '#000000';
                    }
                    
                    // Add handler for the example markers button
                    document.getElementById('add-example-markers').addEventListener('click', addExamplePriceMarkers);
                    
                    // Add a test function to try different marker positions
                    function testMarkerPositions() {
                        log("Testing different marker positions...");
                        
                        // Get a time in the middle of the dataset
                        const midTime = data[Math.floor(data.length / 2)].time;
                        
                        // Choose a test price
                        const testPrice = 25.89;
                        
                        // Log the exact Y coordinate for this price
                        const exactYCoordinate = candlestickSeries.priceToCoordinate(testPrice);
                        log(`Test price ${testPrice} converts to exact Y coordinate: ${exactYCoordinate}`);
                        
                        // Test different position values
                        const positions = [
                            'inBar', 
                            'aboveBar', 
                            'belowBar', 
                            'atPriceTop', 
                            'atPriceBottom', 
                            'atPriceMiddle'
                        ];
                        
                        // Clear any existing markers first
                        createSeriesMarkersFunction(candlestickSeries, []);
                        markers = [];
                        
                        // Create markers with different positions
                        positions.forEach((position, index) => {
                            // Create a marker with this position
                            const marker = {
                                time: midTime,
                                price: testPrice,
                                shape: 'circle',
                                color: '#' + Math.floor(Math.random()*16777215).toString(16), // Random color
                                position: position,
                                text: `Position: ${position}`
                            };
                            
                            // Add the marker
                            setTimeout(() => {
                                try {
                                    // Log detailed information about this marker
                                    log(`Adding test marker with position: ${position} at price: ${testPrice}`);
                                    
                                    // Add the marker
                                    createSeriesMarkersFunction(candlestickSeries, [marker]);
                                    
                                    // Debug: Check price-to-coordinate conversion for this marker
                                    const priceCoordinate = candlestickSeries.priceToCoordinate(testPrice);
                                    log(`Position ${position}: Price ${testPrice} converts to Y coordinate: ${priceCoordinate}`);
                                    
                                    // Add to our markers array
                                    markers.push(marker);
                                    
                                    // Add a price line to visualize the exact price level
                                    addPriceLine(testPrice, marker.color, `${position} at ${testPrice}`);
                                } catch (err) {
                                    log(`Error adding test marker with position ${position}: ${err.message}`);
                                }
                            }, index * 500); // Stagger the additions
                        });
                    }
                    
                    // Add a function to test multiple markers at different price levels simultaneously
                    function debugPricePositions() {
                        log("==== DETAILED PRICE POSITION DEBUGGING ====");
                        
                        // Clear existing markers
                        createSeriesMarkersFunction(candlestickSeries, []);
                        markers = [];
                        
                        // Get a time in the middle of the dataset
                        const midTime = data[Math.floor(data.length / 2)].time;
                        
                        // Define a set of test prices
                        const testPrices = [20, 25, 30, 35];
                        
                        // Get the exact Y coordinates for each price
                        const yCoordinates = testPrices.map(price => {
                            const y = candlestickSeries.priceToCoordinate(price);
                            log(`Price ${price} converts to Y coordinate: ${y}`);
                            return { price, y };
                        });
                        
                        // Create markers at each price for each position type
                        const positions = ['atPriceTop', 'atPriceMiddle', 'atPriceBottom', 'inBar'];
                        const allMarkers = [];
                        
                        testPrices.forEach((price, priceIdx) => {
                            // Add a price line for reference
                            candlestickSeries.createPriceLine({
                                price: price,
                                color: '#FF0000',
                                lineWidth: 1,
                                lineStyle: 2, // Dashed
                                axisLabelVisible: true,
                                title: `Price: ${price}`
                            });
                            
                            // Create markers for each position at this price
                            positions.forEach((position, posIdx) => {
                                // Staggered time for better visualization
                                const timeOffset = posIdx * 86400; // One day in seconds
                                
                                const marker = {
                                    time: midTime + timeOffset,
                                    price: price,
                                    position: position,
                                    shape: 'circle',
                                    color: getPositionColor(position),
                                    text: `${position} @ ${price}`,
                                    size: 2
                                };
                                
                                allMarkers.push(marker);
                            });
                        });
                        
                        // Add all markers at once
                        try {
                            createSeriesMarkersFunction(candlestickSeries, allMarkers);
                            log(`Added ${allMarkers.length} debug markers`);
                            
                            // Store markers
                            markers = allMarkers;
                            
                            // Detailed analysis of marker positions
                            setTimeout(() => {
                                log("Analyzing marker positions...");
                                
                                // Get the rendered marker elements (if possible)
                                // Since we can't directly access the rendered elements, we'll log our expectations
                                allMarkers.forEach(marker => {
                                    const expectedY = candlestickSeries.priceToCoordinate(marker.price);
                                    log(`Marker at price ${marker.price} with position '${marker.position}' should be near Y: ${expectedY}`);
                                });
                            }, 500);
                        } catch (err) {
                            log("Error adding debug markers: " + err.message);
                            console.error("Debug marker error:", err);
                        }
                    }
                    
                    // Helper function to get color for position type
                    function getPositionColor(position) {
                        const colors = {
                            'atPriceTop': '#FF5722',    // Orange
                            'atPriceMiddle': '#9C27B0', // Purple
                            'atPriceBottom': '#2196F3', // Blue
                            'inBar': '#4CAF50'          // Green
                        };
                        return colors[position] || '#000000';
                    }
                    
                    // Add a button to debug price positions
                    document.getElementById('debug-marker').addEventListener('click', debugPricePositions);
                    
                    // Add a continuous debugging function that monitors price coordinates
                    function monitorPriceCoordinates() {
                        log("Starting price coordinate monitor...");
                        
                        // Fixed test prices to monitor
                        const testPrices = [20, 25, 30, 35];
                        
                        // Clear existing markers first
                        createSeriesMarkersFunction(candlestickSeries, []);
                        markers = [];
                        
                        // Get a time in the middle of the dataset
                        const midTime = data[Math.floor(data.length / 2)].time;
                        
                        // Get information about price scale (important for debugging)
                        const priceScaleInfo = () => {
                            const priceScale = chart.priceScale('right');
                            return {
                                autoScale: priceScale.options().autoScale,
                                mode: priceScale.options().mode,
                                invertScale: priceScale.options().invertScale,
                                visible: priceScale.options().visible,
                                entireTextOnly: priceScale.options().entireTextOnly,
                                borderVisible: priceScale.options().borderVisible,
                            };
                        };
                        
                        log('Initial price scale: ' + JSON.stringify(priceScaleInfo()));
                        
                        // Get visible price range
                        const priceRangeInfo = () => {
                            try {
                                const range = chart.priceScale('right').priceRange();
                                if (range) {
                                    return {
                                        min: range.minValue(),
                                        max: range.maxValue(),
                                    };
                                }
                                return 'No price range available';
                            } catch (e) {
                                return 'Error getting price range: ' + e.message;
                            }
                        };
                        
                        log('Initial price range: ' + JSON.stringify(priceRangeInfo()));
                        
                        // Initial coordinates
                        const initialCoordinates = testPrices.map(price => {
                            const y = candlestickSeries.priceToCoordinate(price);
                            log(`INITIAL: Price ${price} converts to Y coordinate: ${y}`);
                            return { price, y };
                        });
                        
                        // Monitor coordinates over time
                        let checkCount = 0;
                        const maxChecks = 5;
                        
                        function checkCoordinates() {
                            checkCount++;
                            log(`==== CHECK #${checkCount} ====`);
                            
                            log('Price scale: ' + JSON.stringify(priceScaleInfo()));
                            log('Price range: ' + JSON.stringify(priceRangeInfo()));
                            
                            // Get current coordinates
                            testPrices.forEach((price, index) => {
                                const currentY = candlestickSeries.priceToCoordinate(price);
                                const initialY = initialCoordinates[index].y;
                                const diff = currentY - initialY;
                                
                                log(`CHECK #${checkCount}: Price ${price} now at Y: ${currentY} (diff: ${diff.toFixed(2)}px)`);
                                
                                // Add visual indicators at this coordinate
                                if (checkCount === 1) {
                                    // Add a price line at the first check
                                    candlestickSeries.createPriceLine({
                                        price: price,
                                        color: '#FF9800',
                                        lineWidth: 1,
                                        lineStyle: 1, // Solid
                                        axisLabelVisible: true,
                                        title: `Monitor: ${price}`
                                    });
                                }
                            });
                            
                            // Continue monitoring if needed
                            if (checkCount < maxChecks) {
                                setTimeout(checkCoordinates, 1000);
                            } else {
                                log("Price coordinate monitoring complete.");
                                
                                // Test with two different methods side by side
                                // Method 1: Direct price-based markers (our current approach)
                                // Method 2: Store the coordinates and use those directly
                                
                                const priceBased = [];
                                const coordBased = [];
                                
                                // Force a price scale update before creating markers
                                log('Forcing price scale update...');
                                chart.priceScale('right').applyOptions({});
                                
                                log('Price scale before adding markers: ' + JSON.stringify(priceScaleInfo()));
                                log('Price range before adding markers: ' + JSON.stringify(priceRangeInfo()));
                                
                                // Create a marker for each approach
                                testPrices.forEach((price, index) => {
                                    // Get latest coordinate
                                    const currentY = candlestickSeries.priceToCoordinate(price);
                                    log(`Before adding markers: Price ${price} at Y: ${currentY}`);
                                    
                                    // Get time offset for side-by-side comparison
                                    const timeOffset = index * 86400 * 2; // Two days spacing between prices
                                    
                                    // Method 1: Price-based marker (left marker)
                                    priceBased.push({
                                        time: midTime + timeOffset,
                                        price: price,
                                        position: 'inBar',
                                        shape: 'circle',
                                        color: '#FF0000', // Red for price-based
                                        text: `Price: ${price}`,
                                        size: 2
                                    });
                                    
                                    // Method 2: Coordinate-based marker (right marker)
                                    // This bypasses our fix but should have similar problems
                                    // as it's using the coordinate from before adding markers
                                    coordBased.push({
                                        time: midTime + timeOffset + 86400, // One day to the right
                                        position: 'inBar',
                                        shape: 'square',
                                        color: '#0000FF', // Blue for coordinate-based
                                        text: `Coord Y: ${currentY.toFixed(1)}`,
                                        size: 2,
                                        // Will be used for direct positioning later
                                        _yCoord: currentY
                                    });
                                });
                                
                                // Add the price-based markers first to maintain scale
                                log('Adding price-based markers...');
                                createSeriesMarkersFunction(candlestickSeries, priceBased);
                                log(`Added ${priceBased.length} price-based markers`);
                                
                                // Store the price-based markers
                                markers = priceBased;
                                
                                // Check if price scale changed after adding markers
                                log('Price scale after adding markers: ' + JSON.stringify(priceScaleInfo()));
                                log('Price range after adding markers: ' + JSON.stringify(priceRangeInfo()));
                                
                                // Final verification after everything settles
                                setTimeout(() => {
                                    // Check final coordinates
                                    log('FINAL CHECK - After markers were added');
                                    log('Price scale: ' + JSON.stringify(priceScaleInfo()));
                                    log('Price range: ' + JSON.stringify(priceRangeInfo()));
                                    
                                    testPrices.forEach(price => {
                                        const finalY = candlestickSeries.priceToCoordinate(price);
                                        log(`FINAL: Price ${price} final Y coordinate: ${finalY}`);
                                    });
                                    
                                    // Add the direct coordinate markers for comparison
                                    // This applies a manual Y offset to match the price-based markers
                                    // (We'd need to modify the library to allow actual coordinate-based positioning)
                                    const finalCoordBased = coordBased.map(marker => {
                                        // Store just what's needed for createSeriesMarkers
                                        return {
                                            time: marker.time,
                                            position: marker.position,
                                            shape: marker.shape,
                                            color: marker.color,
                                            text: marker.text,
                                            size: marker.size
                                        };
                                    });
                                    
                                    createSeriesMarkersFunction(candlestickSeries, [...markers, ...finalCoordBased]);
                                    log(`Added ${coordBased.length} coordinate-based markers for comparison`);
                                }, 500);
                            }
                        }
                        
                        // Start monitoring
                        setTimeout(checkCoordinates, 500);
                    }
                    
                    // Add a button for monitoring price coordinates
                    const monitorButton = document.createElement('button');
                    monitorButton.id = 'monitor-coordinates';
                    monitorButton.textContent = 'Monitor Price Coordinates';
                    monitorButton.addEventListener('click', monitorPriceCoordinates);
                    
                    // Find the control group for the debug button and insert after it
                    const debugButtonGroup = document.getElementById('debug-marker').parentElement;
                    const newControlGroup = document.createElement('div');
                    newControlGroup.className = 'control-group';
                    const label = document.createElement('label');
                    label.innerHTML = '&nbsp;';
                    newControlGroup.appendChild(label);
                    newControlGroup.appendChild(monitorButton);
                    debugButtonGroup.after(newControlGroup);
                    
                } catch (err) {
                    log("Error creating chart: " + err.message);
                    console.error("Chart creation error:", err);
                }
            })
            .catch(err => {
                log("Error importing module: " + err.message);
                console.error("Import error:", err);
            });
        } catch (err) {
            console.error("Script error:", err);
        }
    </script>
</body>
</html> 